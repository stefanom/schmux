package main

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"

	"github.com/sergeknystautas/schmux/internal/api/contracts"
)

type fieldDef struct {
	name     string
	tsType   string
	optional bool
}

type typeDef struct {
	name   string
	fields []fieldDef
}

func main() {
	rootTypes := []reflect.Type{
		reflect.TypeOf(contracts.ConfigResponse{}),
		reflect.TypeOf(contracts.ConfigUpdateRequest{}),
		reflect.TypeOf(contracts.GitGraphResponse{}),
		reflect.TypeOf(contracts.PRsResponse{}),
	}

	typeMap := collectTypes(rootTypes)
	names := make([]string, 0, len(typeMap))
	for name := range typeMap {
		names = append(names, name)
	}
	sort.Strings(names)

	var defs []typeDef
	for _, name := range names {
		defs = append(defs, buildTypeDef(typeMap[name], typeMap))
	}

	out := render(defs)
	outPath := filepath.Join("assets", "dashboard", "src", "lib", "types.generated.ts")
	if err := os.WriteFile(outPath, out, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "failed to write %s: %v\n", outPath, err)
		os.Exit(1)
	}
}

func collectTypes(roots []reflect.Type) map[string]reflect.Type {
	typeMap := make(map[string]reflect.Type)
	queue := append([]reflect.Type(nil), roots...)

	for len(queue) > 0 {
		t := queue[0]
		queue = queue[1:]
		t = deref(t)
		if t.Kind() != reflect.Struct || t.Name() == "" {
			continue
		}
		if !isContractsType(t) {
			continue
		}
		if _, ok := typeMap[t.Name()]; ok {
			continue
		}
		typeMap[t.Name()] = t

		for i := 0; i < t.NumField(); i++ {
			f := t.Field(i)
			if f.Tag.Get("json") == "-" {
				continue
			}
			queue = append(queue, dependentTypes(f.Type)...)
		}
	}

	return typeMap
}

func buildTypeDef(t reflect.Type, known map[string]reflect.Type) typeDef {
	fields := make([]fieldDef, 0, t.NumField())
	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)
		tag := f.Tag.Get("json")
		if tag == "-" {
			continue
		}
		name := jsonFieldName(f.Name, tag)
		if name == "" {
			continue
		}
		optional := isOptionalField(f, tag)
		tsType := goTypeToTS(f.Type, known)
		fields = append(fields, fieldDef{name: name, tsType: tsType, optional: optional})
	}
	return typeDef{name: t.Name(), fields: fields}
}

func render(defs []typeDef) []byte {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by cmd/gen-types; DO NOT EDIT.\n")
	buf.WriteString("\n")
	for _, def := range defs {
		buf.WriteString("export interface ")
		buf.WriteString(def.name)
		buf.WriteString(" {\n")
		for _, field := range def.fields {
			buf.WriteString("  ")
			buf.WriteString(field.name)
			if field.optional {
				buf.WriteString("?: ")
			} else {
				buf.WriteString(": ")
			}
			buf.WriteString(field.tsType)
			buf.WriteString(";\n")
		}
		buf.WriteString("}\n\n")
	}
	return buf.Bytes()
}

func goTypeToTS(t reflect.Type, known map[string]reflect.Type) string {
	t = deref(t)
	switch t.Kind() {
	case reflect.Bool:
		return "boolean"
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
		reflect.Float32, reflect.Float64:
		return "number"
	case reflect.String:
		return "string"
	case reflect.Slice, reflect.Array:
		return goTypeToTS(t.Elem(), known) + "[]"
	case reflect.Map:
		key := t.Key()
		if key.Kind() != reflect.String {
			return "Record<string, unknown>"
		}
		return "Record<string, " + goTypeToTS(t.Elem(), known) + ">"
	case reflect.Struct:
		if t.PkgPath() == "time" && t.Name() == "Time" {
			return "string"
		}
		if t.Name() != "" && isContractsType(t) {
			return t.Name()
		}
		return "Record<string, unknown>"
	default:
		return "unknown"
	}
}

func jsonFieldName(fallback, tag string) string {
	if tag == "" {
		return fallback
	}
	parts := strings.Split(tag, ",")
	if len(parts) == 0 {
		return fallback
	}
	if parts[0] == "" {
		return fallback
	}
	return parts[0]
}

func isOptionalField(f reflect.StructField, tag string) bool {
	if f.Type.Kind() == reflect.Pointer {
		return true
	}
	return strings.Contains(tag, "omitempty")
}

func deref(t reflect.Type) reflect.Type {
	if t.Kind() == reflect.Pointer {
		return t.Elem()
	}
	return t
}

func isContractsType(t reflect.Type) bool {
	return strings.HasSuffix(t.PkgPath(), "/internal/api/contracts")
}

func dependentTypes(t reflect.Type) []reflect.Type {
	t = deref(t)
	switch t.Kind() {
	case reflect.Slice, reflect.Array:
		return dependentTypes(t.Elem())
	case reflect.Map:
		out := dependentTypes(t.Key())
		return append(out, dependentTypes(t.Elem())...)
	case reflect.Struct:
		if t.Name() != "" && isContractsType(t) {
			return []reflect.Type{t}
		}
	}
	return nil
}
